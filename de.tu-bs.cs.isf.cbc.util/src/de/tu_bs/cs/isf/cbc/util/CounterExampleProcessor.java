package de.tu_bs.cs.isf.cbc.util;


import java.util.regex.Matcher;
import java.util.regex.Pattern;

import api.GPTAccess;
import de.tu_bs.cs.isf.cbc.exceptions.SettingsException;

public class CounterExampleProcessor {

    private final GPTAccess gptAccess;

    // Constructor to initialize GPTAccess
    public CounterExampleProcessor() {
        this.gptAccess = new GPTAccess();
    }

    /**
     * Processes a given counterexample, optionally translating it using GPT if enabled.
     *
     * @param originalCounterExample The raw counterexample to be processed.
     * @return The processed counterexample, translated if AI translation is enabled.
     */
    public String generateCounterExample(String originalCounterExample) {
        try {
            // Check if AI Translated Counterexamples are enabled in the settings
            if (Settings.get().isAiTranslatedCounterExamplesEnabled()) {
                System.out.println("AI Translation enabled. Sending counterexample to GPT...");
                return translateCounterExampleWithGPT(originalCounterExample);
            } else {
                // Return the original counterexample if AI translation is disabled
                return originalCounterExample;
            }
        } catch (SettingsException e) {
            e.printStackTrace();
            return originalCounterExample; // Fallback in case of settings retrieval failure
        } catch (Exception e) {
            System.err.println("Error during GPT translation. Returning original counterexample.");
            e.printStackTrace();
            return originalCounterExample; // Fallback in case of GPT API errors
        }
    }

    /**
     * Sends the counterexample to GPT for translation or enhancement.
     *
     * @param counterExample The raw counterexample to be translated.
     * @return The translated counterexample as returned by GPT.
     * @throws Exception If the API call fails.
     */
    private String translateCounterExampleWithGPT(String counterExample) throws Exception {
        // Step 1: Simplify and clean up logical expressions
        String simplifiedCounterExample = simplifyLogicalExpressions(counterExample);

        // Step 2: Sanitize the input
        String sanitizedCounterExample = sanitizePrompt(simplifiedCounterExample);

        // Step 4: Construct the concise prompt
        String prompt = "This is a counter example generated by Z3, that was produced due to the failing of the verification tool key. Could you please rephrase this counter example in a shorter and more understandable way: "+sanitizedCounterExample;

        // Log the final prompt for debugging
        System.out.println("Final Prompt Sent to GPT: " + prompt);

        // Step 5: Send the prompt to GPT with a max_tokens limit
        String response = gptAccess.getResponse(prompt);
        // Regex to find the "content" value
        Pattern pattern = Pattern.compile("\"content\":\\s*\"(.*?)\"");
        Matcher matcher = pattern.matcher(response);

        // Extract and print the content
        if (matcher.find()) {
            String content = matcher.group(1); // Group 1 contains the matched content value
            System.out.println("\u001B[34mResponse from GPT: " + content + "\u001B[0m"); //Output in Blue font
        }
        //System.out.println("Response from GPT: " + response);
        return response;
    }
    private String simplifyLogicalExpressions(String counterExample) {
        if (counterExample == null || counterExample.isEmpty()) {
            return counterExample;
        }

        // Replace binary and hexadecimal values with human-readable descriptions
        counterExample = counterExample.replaceAll("#b(\\d+)", "binary $1")
                                       .replaceAll("#x([0-9a-fA-F]+)", "hexadecimal $1");

        // Remove unnecessary numeric prefixes (e.g., "3)", "4)")
        counterExample = counterExample.replaceAll("\\[\\d+\\)", "")
                                       .replaceAll("\\]", "")
                                       .replaceAll("\\[", "");

        // Summarize and clean up specific constructs
       /*counterExample = counterExample.replaceAll("Bool .*?= \\(.*?\\)", "Logical relationships are present.")
                                       .replaceAll("seq(GetOutside|Empty) = binary \\d+", "Sequence-related variables are zero.")
                                       .replaceAll("null = binary 000", "") // Remove redundant variables
                                       .replaceAll("Bool elementOf = false", "Some variables are not part of the set.");

        */// Replace excessive spaces and trim the result
        return counterExample.replaceAll("\\s+", " ").trim();
    }

    private String sanitizePrompt(String input) {
        return input.replace("\\", "\\\\") // Escape backslashes
                    .replace("\"", "\\\"") // Escape double quotes
                    .replace("\n", " ")   // Replace newlines with spaces
                    .replace("\r", " ")   // Replace carriage returns with spaces
                    .replace("\t", " ")   // Replace tabs with spaces
                    .replaceAll("\\|.*?\\|", "data reference") // Simplify vertical bar constructs
                    .replaceAll("\\s+", " ") // Collapse multiple spaces
                    .trim();
    }

    private String truncatePrompt(String input, int maxLength) {
        return input.length() > maxLength ? input.substring(0, maxLength) + "..." : input;
    }
}
