<?xml version="1.0" encoding="ASCII"?>
<taxonomy:Taxonomy xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:taxonomy="http://www.example.org/taxonomy" name="SamplingTax">
  <Algorithms name="Sampling" abstract="true" childAlgorithms="//@Algorithms.1 //@Algorithms.2" preCondition="" postCondition="" invariant="">
    <dataStructures name="configurations">
      <dataType name="Set&lt;Collection&lt;Integer>>"/>
    </dataStructures>
    <dataStructures name="featureModel">
      <dataType name="FeatureModel"/>
    </dataStructures>
    <dataStructures name="solver">
      <dataType name="ISatSolver"/>
    </dataStructures>
    <methods name="sampling()" pseudoCode="public abstract void sampling();" preCondition="" postCondition=""/>
  </Algorithms>
  <Algorithms name="CoveringArray" abstract="true" childAlgorithms="//@Algorithms.6 //@Algorithms.5 //@Algorithms.4" parentAlgorithms="//@Algorithms.0" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public abstract void sampling();" preCondition="" postCondition=""/>
    <methods name="generateTuple()" pseudoCode="protected Set&lt;List&lt;Integer>> generateTuple() {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;int numberFeatures = this.solver.getSatInstance().getNumberOfVariables();&#xD;&#xA;&#x9;&#x9;for (int i = 1; i &lt;= numberFeatures; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int j = i+1; j &lt;= numberFeatures; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(i, j)));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(i, -j)));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(-i, j)));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(-i, -j)));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return tuples;&#xD;&#xA;&#x9;}"/>
    <methods name="removeInvalid(tuples)" pseudoCode="public Set&lt;List&lt;Integer>> removeInvalid(Set&lt;List&lt;Integer>> tuples) {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuplesRemove = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentPush(tuple.get(0));&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentPush(tuple.get(1));&#xD;&#xA;&#x9;&#x9;&#x9;if (solver.isSatisfiable()  != SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuplesRemove.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;tuples.removeAll(tuplesRemove);&#xD;&#xA;&#x9;&#x9;return tuples;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
    </methods>
  </Algorithms>
  <Algorithms name="Search_based" abstract="true" childAlgorithms="//@Algorithms.3 //@Algorithms.9" parentAlgorithms="//@Algorithms.0" preCondition="" postCondition="" invariant="">
    <dataStructures name="numberIterations">
      <dataType/>
    </dataStructures>
    <dataStructures name="populationSize">
      <dataType/>
    </dataStructures>
    <methods name="sampling()" pseudoCode="public abstract void sampling();" preCondition="" postCondition=""/>
    <methods name="createStartPopulation(population)" pseudoCode="protected abstract void createStartPopulation(Pop population);">
      <dataTypes name="Pop"/>
    </methods>
    <methods name="calculateFitness(population)" pseudoCode="protected abstract double calculateFitness(Pop population);">
      <dataTypes name="Pop"/>
    </methods>
  </Algorithms>
  <Algorithms name="Genetic" abstract="true" childAlgorithms="//@Algorithms.7 //@Algorithms.8" parentAlgorithms="//@Algorithms.2" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public abstract void sampling();" preCondition="" postCondition=""/>
    <methods name="selectIndividual(population)" pseudoCode="protected abstract Indi selectIndividual(Pop population);">
      <dataTypes name="Pop"/>
    </methods>
    <methods name="mutate(chromosome)" pseudoCode="protected abstract void mutate(Chr chromosome);">
      <dataTypes name="Chr"/>
    </methods>
    <methods name="crossover(chromosome,chromosome,chromosome,chromosome)" pseudoCode="protected abstract void crossover(Chr chromosome1,&#xD;&#xA;&#x9;&#x9;&#x9;Chr chromosome2, Chr childChromosome1,&#xD;&#xA;&#x9;&#x9;&#x9;Chr childChromosome2);">
      <dataTypes name="Chr"/>
      <dataTypes name="Chr"/>
      <dataTypes name="Chr"/>
      <dataTypes name="Chr"/>
    </methods>
    <methods name="createStartPopulation(population)" pseudoCode="protected abstract void createStartPopulation(Pop population);">
      <dataTypes name="Pop"/>
    </methods>
    <methods name="calculateFitness(population)" pseudoCode="protected abstract double calculateFitness(Pop population);">
      <dataTypes name="Pop"/>
    </methods>
  </Algorithms>
  <Algorithms name="Chvatal" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples = generateTuple();&#xD;&#xA;&#x9;&#x9;boolean invalidRemoved = false;&#xD;&#xA;&#x9;&#x9;while (!tuples.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;List&lt;Integer>> tuplesCovered = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(tuple.get(0));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(tuple.get(1));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable()  == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(tuple.get(0));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(tuple.get(1));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tuplesCovered.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;tuples.removeAll(tuplesCovered);&#xD;&#xA;&#x9;&#x9;&#x9;if (!tuplesCovered.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int[] resultConfiguration = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i : resultConfiguration) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configurations.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (!invalidRemoved &amp;&amp; Math.log10(tuplesCovered.size()) &lt;= Math.log10(solver.getSatInstance().getNumberOfVariables())) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples = removeInvalid(tuples);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;invalidRemoved = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
  </Algorithms>
  <Algorithms name="ICPL" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;sampling(2);&#x9;&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
    <methods name="sampling(t)" pseudoCode="private Set&lt;List&lt;Integer>> sampling(int t) {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples;&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> invalid1Tuples;&#xD;&#xA;&#x9;&#x9;boolean invalidRemoved = false;&#xD;&#xA;&#x9;&#x9;if (t == 1) {&#xD;&#xA;&#x9;&#x9;&#x9;invalid1Tuples = genCompleteI();&#xD;&#xA;&#x9;&#x9;&#x9;tuples = generate1Tuples();&#xD;&#xA;&#x9;&#x9;&#x9;tuples.removeAll(invalid1Tuples);&#xD;&#xA;&#x9;&#x9;&#x9;invalidRemoved = true;&#xD;&#xA;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;invalid1Tuples = sampling(1);&#xD;&#xA;&#x9;&#x9;&#x9;tuples = generateTuple();&#xD;&#xA;&#x9;&#x9;&#x9;tuples = reduceTuples(tuples, invalid1Tuples);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;while (!tuples.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> configuration;&#xD;&#xA;&#x9;&#x9;&#x9;configuration = genConfiguration(tuples);&#xD;&#xA;&#x9;&#x9;&#x9;configurations.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;List&lt;Integer>> tuplesCovered = getCovered(tuples, configuration);&#xD;&#xA;&#x9;&#x9;&#x9;tuples.removeAll(tuplesCovered);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;if (!invalidRemoved &amp;&amp; Math.log10(tuplesCovered.size()) &lt;= Math.log10(solver.getSatInstance().getNumberOfVariables())) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples = removeInvalid(tuples);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;invalidRemoved = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return invalid1Tuples;&#xD;&#xA;&#x9;}">
      <dataTypes/>
    </methods>
    <methods name="genConfiguration(tuples)" pseudoCode="private Set&lt;Integer> genConfiguration(Set&lt;List&lt;Integer>> tuples) {&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> cf = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> pf = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int assignment : tuple) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;pf.add(Math.abs(assignment));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;solver.setSelectionStrategy(SelectionStrategy.RANDOM);&#xD;&#xA;&#x9;&#x9;Loop: for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> features = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;for (int assignment : tuple) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;features.add(Math.abs(assignment));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (cf.containsAll(features)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;for (int assignment : tuple) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(assignment);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (solver.isSatisfiable()  == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configuration.addAll(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;cf.addAll(features);&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; tuple.size(); i++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int assignment : tuple) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> tempTuple = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempTuple.addAll(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempTuple.remove((Integer) assignment);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if ((tempTuple.isEmpty() || configuration.containsAll(tempTuple)) &amp;&amp; !configuration.contains(assignment)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int invertedAssignment = -assignment;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(invertedAssignment);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(invertedAssignment);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cf.add(Math.abs(invertedAssignment));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (cf.size() == pf.size()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break Loop;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;int[] resultConfiguration = solver.findModel();&#xD;&#xA;&#x9;&#x9;for (int i : resultConfiguration) {&#xD;&#xA;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return configuration;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
    </methods>
    <methods name="genCompleteI()" pseudoCode="private Set&lt;List&lt;Integer>> genCompleteI() {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples = generate1Tuples();&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tempTuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> invalidTuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> notCore = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> notDead = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;if (i &lt; 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;notCore.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;configurations.add(configuration);&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;if (tuple.get(0) &lt; 0 &amp;&amp; !notCore.contains(tuple.get(0))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tempTuples.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;invalidTuples.addAll(getInvalidAssignments(tempTuples));&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;solver.setSelectionStrategy(SelectionStrategy.POSITIVE);&#xD;&#xA;&#x9;&#x9;config = solver.findModel();&#xD;&#xA;&#x9;&#x9;configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;tempTuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;if (i > 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;notDead.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;configurations.add(configuration);&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;if (tuple.get(0) > 0 &amp;&amp; !notCore.contains(tuple.get(0))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tempTuples.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;invalidTuples.addAll(getInvalidAssignments(tempTuples));&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;return invalidTuples;&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;"/>
    <methods name="getInvalidAssignments(tuples)" pseudoCode="private Set&lt;List&lt;Integer>> getInvalidAssignments(Set&lt;List&lt;Integer>> tuples) {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> invalidTuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentPush(tuple.get(0));&#xD;&#xA;&#x9;&#x9;&#x9;if (solver.isSatisfiable() != SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;invalidTuples.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return invalidTuples;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
    </methods>
    <methods name="reduceTuples(tuples,invalid1Tuples)" pseudoCode="private Set&lt;List&lt;Integer>> reduceTuples(Set&lt;List&lt;Integer>> tuples,&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;List&lt;Integer>> invalid1Tuples) {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> newTuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;Loop: for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;for (Collection&lt;Integer> configuration : configurations) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (configuration.contains(tuple.get(0)) &amp;&amp; configuration.contains(tuple.get(1))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue Loop;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;for (List&lt;Integer> invalidTuple : invalid1Tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (tuple.contains(invalidTuple.get(0))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue Loop;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;newTuples.add(tuple);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return newTuples;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
    </methods>
    <methods name="generate1Tuples()" pseudoCode="private Set&lt;List&lt;Integer>> generate1Tuples() {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples = new HashSet&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;int numberFeatures = this.solver.getSatInstance().getNumberOfVariables();&#xD;&#xA;&#x9;&#x9;for (int i = 1; i &lt;= numberFeatures; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int j = i+1; j &lt;= numberFeatures; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(i)));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;tuples.add(new ArrayList&lt;Integer>(Arrays.asList(-i)));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return tuples;&#xD;&#xA;&#x9;}"/>
  </Algorithms>
  <Algorithms name="IncLing" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="">
    <dataStructures name="totalNumberTuples">
      <dataType name="double"/>
    </dataStructures>
    <dataStructures name="coverage">
      <dataType name="double"/>
    </dataStructures>
    <dataStructures name="threshold">
      <dataType name="double"/>
    </dataStructures>
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;int numberFeatures = this.solver.getSatInstance().getNumberOfVariables();&#xD;&#xA;&#x9;&#x9;List&lt;FeatureIndex> featureList = new ArrayList&lt;FeatureIndex>();&#xD;&#xA;&#x9;&#x9;for (int i = 1; i &lt;= numberFeatures; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;featureList.add(new FeatureIndex(i));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> tuples = generateTuple();&#xD;&#xA;&#x9;&#x9;tuples = removeInvalid(tuples);&#xD;&#xA;&#x9;&#x9;totalNumberTuple = tuples.size();&#xD;&#xA;&#x9;&#x9;coverage = 0;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;while (!tuples.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;updateFrequency(featureList, tuples);&#xD;&#xA;&#x9;&#x9;&#x9;Collections.sort(featureList);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;for (int i = 1; i &lt; numberFeatures; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0; j &lt; i; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;List&lt;List&lt;Integer>> testTuples = getTuples(tuples, featureList.get(i), featureList.get(j));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;testTuples(testTuples, configuration);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;int[] resultConfiguration = solver.findModel();&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;for (int i : resultConfiguration) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;configurations.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;List&lt;Integer>> tuplesCovered = getCovered(tuples, configuration);&#xD;&#xA;&#x9;&#x9;&#x9;tuples.removeAll(tuplesCovered);&#xD;&#xA;&#x9;&#x9;&#x9;coverage = totalNumberTuple - tuples.size();&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
    <methods name="testTuples(testTuples,configuration)" pseudoCode="private void testTuples(List&lt;List&lt;Integer>> testTuples, Set&lt;Integer> configuration) {&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : testTuples) {&#xD;&#xA;&#x9;&#x9;&#x9;int feature1 = tuple.get(0);&#xD;&#xA;&#x9;&#x9;&#x9;int feature2 = tuple.get(1);&#xD;&#xA;&#x9;&#x9;&#x9;boolean wasUndefined1 = !configuration.contains(feature1);&#xD;&#xA;&#x9;&#x9;&#x9;boolean wasUndefined2 = !configuration.contains(feature2);&#xD;&#xA;&#x9;&#x9;&#x9;if (configuration.contains(feature1) || configuration.contains(-feature1) || configuration.contains(feature2) || configuration.contains(-feature2)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if ((configuration.contains(-feature1) || configuration.contains(-feature2)) &#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;|| (configuration.contains(feature1) &amp;&amp; configuration.contains(feature2))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;|| (coverage / totalNumberTuple) &lt; threshold) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (!configuration.contains(feature2)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(feature2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable()  == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(feature2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(-feature2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(-feature2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (!configuration.contains(feature1)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(feature1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configuration.add(feature1);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (solver.isSatisfiable() == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return;&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (wasUndefined2) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (wasUndefined1) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.remove(feature1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.remove(feature2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.remove(feature1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(-feature1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPop();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(-feature1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;List&lt;Integer>>"/>
      <dataTypes name="Set&lt;Integer>"/>
    </methods>
    <methods name="getTuples(tuples,featureIndex,featureIndex2)" pseudoCode="private List&lt;List&lt;Integer>> getTuples(Set&lt;List&lt;Integer>> tuples, FeatureIndex featureIndex, FeatureIndex featureIndex2) {&#xD;&#xA;&#x9;&#x9;List&lt;List&lt;Integer>> testTuple = new ArrayList&lt;>();&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;if ((tuple.contains(featureIndex.index) || tuple.contains(-featureIndex.index)) &amp;&amp; (tuple.contains(featureIndex2.index) || tuple.contains(-featureIndex2.index))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;testTuple.add(tuple);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;List&lt;List&lt;Integer>> sortedTuple = new ArrayList&lt;>();&#xD;&#xA;&#x9;&#x9;List&lt;Integer> negNeg;&#xD;&#xA;&#x9;&#x9;List&lt;Integer> negPos;&#xD;&#xA;&#x9;&#x9;List&lt;Integer> posNeg;&#xD;&#xA;&#x9;&#x9;List&lt;Integer> posPos;&#xD;&#xA;&#x9;&#x9;if (Math.abs(featureIndex.index) &lt; Math.abs(featureIndex2.index)) {&#xD;&#xA;&#x9;&#x9;&#x9;negNeg = new ArrayList&lt;>(Arrays.asList(-featureIndex.index, -featureIndex2.index));&#xD;&#xA;&#x9;&#x9;&#x9;negPos = new ArrayList&lt;>(Arrays.asList(-featureIndex.index, featureIndex2.index));&#xD;&#xA;&#x9;&#x9;&#x9;posNeg = new ArrayList&lt;>(Arrays.asList(featureIndex.index, -featureIndex2.index));&#xD;&#xA;&#x9;&#x9;&#x9;posPos = new ArrayList&lt;>(Arrays.asList(featureIndex.index, featureIndex2.index));&#xD;&#xA;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;negNeg = new ArrayList&lt;>(Arrays.asList(-featureIndex2.index, -featureIndex.index));&#xD;&#xA;&#x9;&#x9;&#x9;negPos = new ArrayList&lt;>(Arrays.asList(-featureIndex2.index, featureIndex.index));&#xD;&#xA;&#x9;&#x9;&#x9;posNeg = new ArrayList&lt;>(Arrays.asList(featureIndex2.index, -featureIndex.index));&#xD;&#xA;&#x9;&#x9;&#x9;posPos = new ArrayList&lt;>(Arrays.asList(featureIndex2.index, featureIndex.index));&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;if (featureIndex.signum &lt; 0) {&#xD;&#xA;&#x9;&#x9;&#x9;if (featureIndex2.signum &lt; 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;if (featureIndex2.signum &lt; 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negPos)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negPos);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(posNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(posNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (testTuple.contains(negNeg)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sortedTuple.add(negNeg);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return sortedTuple;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
      <dataTypes name="FeatureIndex"/>
      <dataTypes name="FeatureIndex"/>
    </methods>
    <methods name="updateFrequency(featureList,tuples)" pseudoCode="private void updateFrequency(List&lt;FeatureIndex> featureList, Set&lt;List&lt;Integer>> tuples) {&#xD;&#xA;&#x9;&#x9;for (FeatureIndex feature : featureList) {&#xD;&#xA;&#x9;&#x9;&#x9;feature.frequency = 0;&#xD;&#xA;&#x9;&#x9;&#x9;feature.signum = 0;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;for (List&lt;Integer> tuple : tuples) {&#xD;&#xA;&#x9;&#x9;&#x9;for (FeatureIndex feature : featureList) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (Math.abs(tuple.get(0)) == feature.index) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;feature.frequency++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (tuple.get(0) > 0 ) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;feature.signum++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;feature.signum--;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (Math.abs(tuple.get(1)) == feature.index) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;feature.frequency++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (tuple.get(1) > 0 ) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;feature.signum++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;feature.signum--;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;FeatureIndex>"/>
      <dataTypes name="Set&lt;List&lt;Integer>>"/>
    </methods>
  </Algorithms>
  <Algorithms name="Genetic multi_objective" parentAlgorithms="//@Algorithms.3" preCondition="" postCondition="" invariant="">
    <dataStructures name="maximumIndividualSize">
      <dataType/>
    </dataStructures>
    <dataStructures name="elitismSize">
      <dataType/>
    </dataStructures>
    <dataStructures name="maxCoverage">
      <dataType/>
    </dataStructures>
    <dataStructures name="maxTestingCost">
      <dataType/>
    </dataStructures>
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;Map&lt;Set&lt;Set&lt;Integer>>, Double> population = new HashMap&lt;Set&lt;Set&lt;Integer>>, Double>();&#xD;&#xA;&#x9;&#x9;createStartPopulation(population);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;for (int i = 0; i &lt; numberIterations; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;Map&lt;Set&lt;Set&lt;Integer>>, Double> newPopulation = new HashMap&lt;Set&lt;Set&lt;Integer>>, Double>();&#xD;&#xA;&#x9;&#x9;&#x9;for (Set&lt;Set&lt;Integer>> individual : population.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newPopulation.put(individual, population.get(individual));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;while (newPopulation.size() > elitismSize) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> removeIndividual = null;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;double biggest = 0;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (Set&lt;Set&lt;Integer>> individual : newPopulation.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newPopulation.get(individual) > biggest) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;biggest = newPopulation.get(individual);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeIndividual = individual;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newPopulation.remove(removeIndividual);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9; &#xD;&#xA;&#x9;&#x9;&#x9;int s = random.nextInt(maximumIndividualSize) + 1;&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;while (individual.size() &lt; s) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;double fitness = calculateFitness(individual);&#xD;&#xA;&#x9;&#x9;&#x9;newPopulation.put(individual, fitness);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;while (newPopulation.size() &lt; populationSize) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual1 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual2 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> childIndividual1 = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> childIndividual2 = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;crossover(individual1, individual2, childIndividual1, childIndividual2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (random.nextDouble() &lt; 0.5) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;mutate(childIndividual1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (random.nextDouble() &lt; 0.5) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;mutate(childIndividual2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;double fitness1 = calculateFitness(childIndividual1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newPopulation.put(childIndividual1, fitness1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;double fitness2 = calculateFitness(childIndividual2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newPopulation.put(childIndividual2, fitness2);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;while (newPopulation.size() > populationSize) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> removeIndividual = null;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;double biggest = 0;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (Set&lt;Set&lt;Integer>> nextIndividual : newPopulation.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newPopulation.get(nextIndividual) > biggest) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;biggest = newPopulation.get(nextIndividual);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeIndividual = nextIndividual;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;newPopulation.remove(removeIndividual);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;population = newPopulation;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> bestIndividual = null;&#xD;&#xA;&#x9;&#x9;double smallest = 1;&#xD;&#xA;&#x9;&#x9;for (Set&lt;Set&lt;Integer>> individual : population.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;if (population.get(individual) &lt; smallest) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;smallest = population.get(individual);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;bestIndividual = individual;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;configurations.addAll(bestIndividual);&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
    <methods name="createStartPopulation(population)" pseudoCode="protected void createStartPopulation(Map&lt;Set&lt;Set&lt;Integer>>, Double> population) {&#xD;&#xA;&#x9;&#x9;solver.setSelectionStrategy(SelectionStrategy.RANDOM);&#xD;&#xA;&#x9;&#x9;do {&#xD;&#xA;&#x9;&#x9;&#x9;int s = random.nextInt(maximumIndividualSize) + 1;&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;while (individual.size() &lt; s) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;double fitness = calculateFitness(individual);&#xD;&#xA;&#x9;&#x9;&#x9;population.put(individual, fitness);&#xD;&#xA;&#x9;&#x9;} while (population.size() &lt; populationSize);&#xD;&#xA;&#x9;}">
      <dataTypes name="Map&lt;Set&lt;Set&lt;Integer>>,Double>"/>
    </methods>
    <methods name="calculateFitness(individual)" pseudoCode="protected double calculateFitness(Set&lt;Set&lt;Integer>> individual) {&#xD;&#xA;&#x9;&#x9;double coverage = 0;&#xD;&#xA;&#x9;&#x9;double products = individual.size();&#xD;&#xA;&#x9;&#x9;double testingCost = 0;&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> tuples = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;for (Set&lt;Integer> configuration : individual) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int i : configuration) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (i > 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;testingCost++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : configuration) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (i != j) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;tuples.add(new HashSet&lt;Integer>(Arrays.asList(i, j)));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;coverage = tuples.size();&#xD;&#xA;&#x9;&#x9;double fitness = (wCoverage * (1 - coverage/maxCoverage)) + wProducts * (products/maximumIndividualSize) + wTestingCost * (testingCost/maxTestingCost);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;return fitness;&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="mutate(childIndividual)" pseudoCode="protected void mutate(Set&lt;Set&lt;Integer>> childIndividual) {&#xD;&#xA;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;Iterator&lt;Set&lt;Integer>> it = childIndividual.iterator();&#xD;&#xA;&#x9;&#x9;Set&lt;Integer> remove = it.next();&#xD;&#xA;&#x9;&#x9;childIndividual.remove(remove);&#xD;&#xA;&#x9;&#x9;childIndividual.add(configuration);&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="crossover(individual1,individual1,childIndividual1,childIndividual2)" pseudoCode="protected void crossover(Set&lt;Set&lt;Integer>> individual1,&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual2, Set&lt;Set&lt;Integer>> childIndividual1,&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Set&lt;Integer>> childIndividual2) {&#xD;&#xA;&#x9;&#x9;int number = random.nextInt(Math.min(individual1.size(), individual2.size()));&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual1Stay = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual2Stay = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual1Remove = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> individual2Remove = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;Iterator&lt;Set&lt;Integer>> it1 = individual1.iterator();&#xD;&#xA;&#x9;&#x9;int counter = 0;&#xD;&#xA;&#x9;&#x9;while (it1.hasNext()) {&#xD;&#xA;&#x9;&#x9;&#x9;if (counter &lt; number) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual1Remove.add(it1.next());&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual1Stay.add(it1.next());&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;counter++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;counter = 0;&#xD;&#xA;&#x9;&#x9;Iterator&lt;Set&lt;Integer>> it2 = individual2.iterator();&#xD;&#xA;&#x9;&#x9;while (it2.hasNext()) {&#xD;&#xA;&#x9;&#x9;&#x9;if (counter &lt; number) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual2Remove.add(it2.next());&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;individual2Stay.add(it2.next());&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;counter++;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;childIndividual1.addAll(individual1Stay);&#xD;&#xA;&#x9;&#x9;childIndividual1.addAll(individual2Remove);&#xD;&#xA;&#x9;&#x9;childIndividual2.addAll(individual2Stay);&#xD;&#xA;&#x9;&#x9;childIndividual2.addAll(individual1Remove);&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
      <dataTypes name="Set&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="selectIndividual(population)" pseudoCode="protected Set&lt;Set&lt;Integer>> selectIndividual(Map&lt;Set&lt;Set&lt;Integer>>, Double> population) {&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Set&lt;Integer>>> keySet = population.keySet();&#xD;&#xA;&#x9;&#x9;List&lt;Set&lt;Set&lt;Integer>>> keyList = new ArrayList&lt;Set&lt;Set&lt;Integer>>>(keySet);&#xD;&#xA;&#x9;&#x9;boolean notaccepted = true;&#xD;&#xA;&#x9;&#x9;int index = 0;&#xD;&#xA;&#x9;&#x9;while (notaccepted){&#xD;&#xA;&#x9;&#x9;&#x9;index = random.nextInt(keyList.size());&#xD;&#xA;&#x9;&#x9;&#x9;if (random.nextDouble() > population.get(keyList.get(index))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;notaccepted = false;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return keyList.get(index);&#xD;&#xA;&#x9;}">
      <dataTypes name="Map&lt;Set&lt;Set&lt;Integer>>,Double>"/>
    </methods>
  </Algorithms>
  <Algorithms name="Evolutionary search_based" parentAlgorithms="//@Algorithms.3" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;Map&lt;List&lt;Integer>, Double> population = new HashMap&lt;List&lt;Integer>, Double>();&#xD;&#xA;&#x9;&#x9;createStartPopulation(population);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;for (int i = 0; i &lt; numberIterations; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;List&lt;Integer>> removeConfigurations = new ArrayList&lt;List&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;&#x9;for (List&lt;Integer> configuration : population.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (random.nextDouble() &lt; population.get(configuration)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeConfigurations.add(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;for (List&lt;Integer> removeConfiguration : removeConfigurations) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;population.remove(removeConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;while (population.size() &lt; populationSize) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int size = population.size();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//add conf if empty&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (size == 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (int j : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness = calculateFitness(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(configuration, fitness);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration1 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration2 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration3 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration4 = selectIndividual(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> childConfiguration1 = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> childConfiguration2 = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> childConfiguration3 = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> childConfiguration4 = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;crossover(configuration1, configuration2, childConfiguration1, childConfiguration2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration3.addAll(configuration3);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration4.addAll(configuration4);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;mutate(childConfiguration3);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;mutate(childConfiguration4);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : childConfiguration1) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable() == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness1 = calculateFitness(childConfiguration1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(childConfiguration1, fitness1);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : childConfiguration2) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable() == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness2 = calculateFitness(childConfiguration2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(childConfiguration2, fitness2);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : childConfiguration3) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable() == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness3 = calculateFitness(childConfiguration3);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(childConfiguration3, fitness3);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : childConfiguration4) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentPush(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (solver.isSatisfiable() == SatResult.TRUE) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness4 = calculateFitness(childConfiguration4);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(childConfiguration4, fitness4);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;//add new random configuration if stuck&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (size == population.size()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;solver.assignmentClear(0);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> configuration = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for (int j : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;configuration.add(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;double fitness = calculateFitness(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;population.put(configuration, fitness);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;while (population.size() > populationSize) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;List&lt;Integer> removeConfiguration = null;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;double biggest = 0;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (List&lt;Integer> nextConf : population.keySet()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (population.get(nextConf) > biggest) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;biggest = population.get(nextConf);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeConfiguration = nextConf;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;population.remove(removeConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;configurations.addAll(population.keySet());&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
    <methods name="createStartPopulation(population)" pseudoCode="protected void createStartPopulation(Map&lt;List&lt;Integer>, Double> population) {&#xD;&#xA;&#x9;&#x9;solver.setSelectionStrategy(SelectionStrategy.RANDOM);&#xD;&#xA;&#x9;&#x9;do {&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;Integer> configuration = new ArrayList&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;double fitness = calculateFitness(configuration);&#xD;&#xA;&#x9;&#x9;&#x9;population.put(configuration, fitness);&#xD;&#xA;&#x9;&#x9;} while (population.size() &lt; populationSize);&#xD;&#xA;&#x9;}">
      <dataTypes name="Map&lt;List&lt;Integer>,Double>"/>
    </methods>
    <methods name="calculateFitness(configuration)" pseudoCode="protected double calculateFitness(List&lt;Integer> configuration) {&#xD;&#xA;&#x9;&#x9;double variabilityCoverage = 0;&#xD;&#xA;&#x9;&#x9;double cyclomaticComplexity = 0;&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;for (Integer featureAsInt : configuration) {&#xD;&#xA;&#x9;&#x9;&#x9;if (featureAsInt > 0) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;variabilityCoverage++;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;NextConstraint: for (IConstraint constraint : this.featureModel.getConstraints()) {&#xD;&#xA;&#x9;&#x9;&#x9;for (IFeature feature : constraint.getContainedFeatures()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (Integer featureAsInt : configuration) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;String stringOfFeatureAsInt = this.solver.getSatInstance().getLiteral(Math.abs(featureAsInt)).toString();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (feature.getName().equals(stringOfFeatureAsInt)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;cyclomaticComplexity++;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;continue NextConstraint;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return Math.hypot(variabilityCoverage, cyclomaticComplexity);&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Integer>"/>
    </methods>
    <methods name="mutate(childConfiguration)" pseudoCode="protected void mutate(List&lt;Integer> childConfiguration) {&#xD;&#xA;&#x9;&#x9;int index = random.nextInt(childConfiguration.size());&#xD;&#xA;&#x9;&#x9;childConfiguration.set(index, -childConfiguration.get(index));&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Integer>"/>
    </methods>
    <methods name="crossover(configuration1,configuraton2,childConfiguration1,childConfiguration2)" pseudoCode="protected void crossover(List&lt;Integer> configuration1,&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;Integer> configuration2, List&lt;Integer> childConfiguration1,&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;Integer> childConfiguration2) {&#xD;&#xA;&#x9;&#x9;int number = random.nextInt(Math.min(configuration1.size(), configuration2.size()));&#xD;&#xA;&#x9;&#x9;for (int i = 0; i &lt; configuration1.size(); i++) {&#xD;&#xA;&#x9;&#x9;&#x9;if (i &lt;= number) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration1.add(configuration1.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration2.add(configuration2.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration1.add(configuration2.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;childConfiguration2.add(configuration1.get(i));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Integer>"/>
      <dataTypes name="List&lt;Integer>"/>
      <dataTypes name="List&lt;Integer>"/>
      <dataTypes name="List&lt;Integer>"/>
    </methods>
    <methods name="selectIndividual(population)" pseudoCode="protected List&lt;Integer> selectIndividual(Map&lt;List&lt;Integer>, Double> population) {&#xD;&#xA;&#x9;&#x9;Set&lt;List&lt;Integer>> keySet = population.keySet();&#xD;&#xA;&#x9;&#x9;List&lt;List&lt;Integer>> keyList = new ArrayList&lt;List&lt;Integer>>(keySet);&#xD;&#xA;&#x9;&#x9;boolean notaccepted = true;&#xD;&#xA;&#x9;&#x9;int index = 0;&#xD;&#xA;&#x9;&#x9;while (notaccepted){&#xD;&#xA;&#x9;&#x9;&#x9;index = random.nextInt(keyList.size());&#xD;&#xA;&#x9;&#x9;&#x9;if (random.nextDouble() * maxFitnessValue > population.get(keyList.get(index))) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;notaccepted = false;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return keyList.get(index);&#xD;&#xA;&#x9;}">
      <dataTypes name="Map&lt;List&lt;Integer>,Double>"/>
    </methods>
  </Algorithms>
  <Algorithms name="Similarity search_based" parentAlgorithms="//@Algorithms.2" preCondition="" postCondition="" invariant="">
    <methods name="sampling()" pseudoCode="public void sampling() {&#xD;&#xA;&#x9;&#x9;List&lt;Set&lt;Integer>> population = new ArrayList&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;createStartPopulation(population);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;for (int i = 0; i &lt; numberIterations; i++) {&#xD;&#xA;&#x9;&#x9;&#x9;double fitness = calculateFitness(population);&#xD;&#xA;&#x9;&#x9;&#x9;population = globalMaximumDistance(population);&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> worstConfiguration = population.get(population.size()-1);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> newConfiguration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;do {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;solver.shuffleOrder();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newConfiguration.add(j);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;} while (newConfiguration.equals(worstConfiguration));&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;population.set(population.size()-1, newConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;double newFitness = calculateFitness(population);&#xD;&#xA;&#x9;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;if (newFitness &lt;= fitness) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;population.set(population.size()-1, worstConfiguration);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;configurations.addAll(population);&#xD;&#xA;&#x9;}" preCondition="" postCondition=""/>
    <methods name="createStartPopulation(population)" pseudoCode="protected void createStartPopulation(List&lt;Set&lt;Integer>> population) {&#xD;&#xA;&#x9;&#x9;Set&lt;Set&lt;Integer>> tmpPopulation = new HashSet&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;solver.setSelectionStrategy(SelectionStrategy.RANDOM);&#xD;&#xA;&#x9;&#x9;do {&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;Integer> configuration = new HashSet&lt;Integer>();&#xD;&#xA;&#x9;&#x9;&#x9;int[] config = solver.findModel();&#xD;&#xA;&#x9;&#x9;&#x9;for (int i : config) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;configuration.add(i);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;tmpPopulation.add(configuration);&#xD;&#xA;&#x9;&#x9;} while (tmpPopulation.size() &lt; populationSize);&#xD;&#xA;&#x9;&#x9;population.addAll(tmpPopulation);&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="calculateFitness(population)" pseudoCode="protected double calculateFitness(List&lt;Set&lt;Integer>> population) {&#xD;&#xA;&#x9;&#x9;double fitness = 0;&#xD;&#xA;&#x9;&#x9;for (int i = 1; i &lt; population.size(); i++) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int j = 0; j &lt; i; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;fitness += calculateDistance(population.get(i), population.get(j));&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return fitness;&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="globalMaximumDistance(population)" pseudoCode="private List&lt;Set&lt;Integer>> globalMaximumDistance(List&lt;Set&lt;Integer>> population) {&#xD;&#xA;&#x9;&#x9;List&lt;Set&lt;Integer>> newPopulation = new ArrayList&lt;Set&lt;Integer>>();&#xD;&#xA;&#x9;&#x9;double maxDistance = 0;&#xD;&#xA;&#x9;&#x9;int conf1 = 0;&#xD;&#xA;&#x9;&#x9;int conf2 = 0;&#xD;&#xA;&#x9;&#x9;for (int i = 1; i &lt; population.size(); i++) {&#xD;&#xA;&#x9;&#x9;&#x9;for (int j = 0; j &lt; i; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (calculateDistance(population.get(i), population.get(j)) > maxDistance) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;maxDistance = calculateDistance(population.get(i), population.get(j));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;conf1 = i;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;conf2 = j;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;newPopulation.add(population.get(conf1));&#xD;&#xA;&#x9;&#x9;newPopulation.add(population.get(conf2));&#xD;&#xA;&#x9;&#x9;population.remove(conf1);&#xD;&#xA;&#x9;&#x9;population.remove(conf2);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;while (population.size() > 0) {&#xD;&#xA;&#x9;&#x9;&#x9;maxDistance = 0;&#xD;&#xA;&#x9;&#x9;&#x9;int conf = 0;&#xD;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; population.size(); i++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;int tmpDistance = 0;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0; j &lt; newPopulation.size(); j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tmpDistance += calculateDistance(population.get(i), newPopulation.get(j));&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (tmpDistance > maxDistance) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;maxDistance = tmpDistance;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;conf = i;&#x9;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;newPopulation.add(population.get(conf));&#xD;&#xA;&#x9;&#x9;&#x9;population.remove(conf);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return newPopulation;&#xD;&#xA;&#x9;}">
      <dataTypes name="List&lt;Set&lt;Integer>>"/>
    </methods>
    <methods name="calculateDistance(configuration1,configuration2)" pseudoCode="private double calculateDistance(Set&lt;Integer> configuration1, Set&lt;Integer> configuration2) {&#xD;&#xA;&#x9;&#x9;double difference = Sets.intersection(configuration1, configuration2).size();&#xD;&#xA;&#x9;&#x9;double union = Sets.union(configuration1, configuration2).size();&#xD;&#xA;&#x9;&#x9;return 1 - (difference / union);&#xD;&#xA;&#x9;}">
      <dataTypes name="Set&lt;Integer>"/>
      <dataTypes name="Set&lt;Integer>"/>
    </methods>
  </Algorithms>
</taxonomy:Taxonomy>
