<?xml version="1.0" encoding="ASCII"?>
<taxonomy:Taxonomy xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:taxonomy="http://www.example.org/taxonomy" name="MadfaTax">
  <Algorithms name="AlgorithmSkeleton" abstract="true" childAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.Iterator;&#xD;&#xA;import java.util.List;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Automaton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected abstract void addWord(String word);">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected abstract void cleanup();"/>
  </Algorithms>
  <Algorithms name="Algorithm Trie" childAlgorithms="//@Algorithms.2 //@Algorithms.4 //@Algorithms.5 //@Algorithms.6 //@Algorithms.7" parentAlgorithms="//@Algorithms.0" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.List;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Transition;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;int height = 0;&#xD;&#xA;&#x9;List&lt;State> heightLevel = new ArrayList&lt;State>();&#xD;&#xA;&#x9;while (!(heightLevel = Util.heightLevel(automaton, height)).isEmpty()) {&#xD;&#xA;&#x9;&#x9;for(State stateP : heightLevel) {&#xD;&#xA;&#x9;&#x9;&#x9;if (automaton.getStates().contains(stateP)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for(State stateQ : heightLevel) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (automaton.getStates().contains(stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!stateP.equals(stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (State.isEquivalenceFast(stateP, stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, stateQ, stateP);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;height++;&#xD;&#xA;&#x9;}&#xD;&#xA;}"/>
  </Algorithms>
  <Algorithms name="Algorithm General" childAlgorithms="//@Algorithms.3" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Transition;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right)) &amp;&amp; !Util.getNextState(currentState, Util.head(right)).isConfluence()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State nextState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;State cloneState = Util.cloneState(automaton, nextState);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;Transition transition = currentState.getTransition(nextState, nextChar);&#xD;&#xA;&#x9;&#x9;nextState.getIncomingTransitions().remove(transition);&#xD;&#xA;&#x9;&#x9;transition.setEndState(cloneState);&#xD;&#xA;&#x9;&#x9;cloneState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(cloneState);&#xD;&#xA;&#x9;&#x9;if(cloneState.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;automaton.addFinalState(cloneState);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;currentState = cloneState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;int height = 0;&#xD;&#xA;&#x9;List&lt;State> heightLevel = new ArrayList&lt;State>();&#xD;&#xA;&#x9;while (!(heightLevel = Util.heightLevel(automaton, height)).isEmpty()) {&#xD;&#xA;&#x9;&#x9;for(State stateP : heightLevel) {&#xD;&#xA;&#x9;&#x9;&#x9;if (automaton.getStates().contains(stateP)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for(State stateQ : heightLevel) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (automaton.getStates().contains(stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!stateP.equals(stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (State.isEquivalenceFast(stateP, stateQ)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, stateQ, stateP);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;height++;&#xD;&#xA;&#x9;}&#xD;&#xA;}"/>
  </Algorithms>
  <Algorithms name="Algorithm Incremental" parentAlgorithms="//@Algorithms.2" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.List;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Transition;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right)) &amp;&amp; !Util.getNextState(currentState, Util.head(right)).isConfluence()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State nextState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;State cloneState = Util.cloneState(automaton, nextState);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;Transition transition = currentState.getTransition(nextState, nextChar);&#xD;&#xA;&#x9;&#x9;nextState.getIncomingTransitions().remove(transition);&#xD;&#xA;&#x9;&#x9;transition.setEndState(cloneState);&#xD;&#xA;&#x9;&#x9;cloneState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(cloneState);&#xD;&#xA;&#x9;&#x9;if(cloneState.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;automaton.addFinalState(cloneState);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;currentState = cloneState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#xD;&#xA;&#x9;visitMin(automaton.getStartState(), &quot;&quot;, word);&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;}"/>
    <methods name="visitMin(state,left,right)" pseudoCode="private void visitMin(State state, String left, String right) {&#xD;&#xA;&#x9;String completeWord = left + right;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;if(!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;left += Util.head(right);&#xD;&#xA;&#x9;&#x9;visitMin(Util.getNextState(state, Util.head(right)), left, Util.tail(right));&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;List&lt;State> checkStates = new ArrayList&lt;State>();&#xD;&#xA;&#x9;if(!state.getOutgoingTransitions().isEmpty()) {&#xD;&#xA;&#x9;&#x9;State endState = state.getOutgoingTransitions().get(0).getEndState();&#xD;&#xA;&#x9;&#x9;for(Transition transition : endState.getIncomingTransitions()) {&#xD;&#xA;&#x9;&#x9;&#x9;State startState = transition.getStartState();&#xD;&#xA;&#x9;&#x9;&#x9;if(startState.isFinalState() == state.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;checkStates.add(startState);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;} else if (state.isFinalState()) {&#xD;&#xA;&#x9;&#x9;for (State tmpState : automaton.getFinalStates()) {&#xD;&#xA;&#x9;&#x9;&#x9;if(tmpState.getOutgoingTransitions().isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;checkStates.add(tmpState);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;List&lt;State> pathOfStartState = Util.pathOfState(automaton.getStartState(), completeWord);&#xD;&#xA;&#x9;&#x9;for (State tmpState : automaton.getStates()) {&#xD;&#xA;&#x9;&#x9;&#x9;checkStates.add(tmpState);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;checkStates.removeAll(pathOfStartState);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;for(State q : checkStates) {&#xD;&#xA;&#x9;&#x9;if (automaton.getStates().contains(state)) {&#xD;&#xA;&#x9;&#x9;&#x9;if (!q.equals(state)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(State.isEquivalenceFast(state, q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, state, q);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}">
      <dataTypes name="State"/>
      <dataTypes name="String"/>
      <dataTypes name="String"/>
    </methods>
  </Algorithms>
  <Algorithms name="Algorithm Reverse" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.HashSet;&#xD;&#xA;import java.util.List;&#xD;&#xA;import java.util.Set;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Automaton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Transition;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;word = Util.reverse(word);&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#x9;&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;Automaton reversedAutomat = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;reversedAutomat.setStartState(startState);&#xD;&#xA;&#x9;reversedAutomat.addState(startState);&#xD;&#xA;&#x9;List&lt;Set&lt;State>> toDo = new ArrayList&lt;Set&lt;State>>();&#xD;&#xA;&#x9;List&lt;State> registry = new ArrayList&lt;State>();&#xD;&#xA;&#x9;registry.add(startState);&#xD;&#xA;&#x9;String stateString = &quot;&quot;;&#xD;&#xA;&#x9;Set&lt;State> stateSet = new HashSet&lt;State>();&#xD;&#xA;&#x9;for (State finalState : this.automaton.getFinalStates()) {&#xD;&#xA;&#x9;&#x9;stateSet.add(finalState);&#xD;&#xA;&#x9;&#x9;stateString += finalState.getId() + &quot;;&quot;;&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;toDo.add(stateSet);&#xD;&#xA;&#x9;startState.setId(stateString);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while(!toDo.isEmpty()) {&#xD;&#xA;&#x9;&#x9;Set&lt;State> nextStateSet = toDo.get(0);&#xD;&#xA;&#x9;&#x9;toDo.remove(0);&#xD;&#xA;&#x9;&#x9;String startStateString = &quot;&quot;;&#xD;&#xA;&#x9;&#x9;boolean isFinal = false;&#xD;&#xA;&#x9;&#x9;for (State tmpState : nextStateSet) {&#xD;&#xA;&#x9;&#x9;&#x9;startStateString += tmpState.getId() + &quot;;&quot;;&#xD;&#xA;&#x9;&#x9;&#x9;if(automaton.getStartState().equals(tmpState)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;isFinal = true;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;for(char letter = 'a'; letter &lt;= 'z'; letter++) {&#xD;&#xA;&#x9;&#x9;&#x9;String letterAsString = Character.toString(letter);&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;State> newStateSet = new HashSet&lt;State>();&#xD;&#xA;&#x9;&#x9;&#x9;String newStateString = &quot;&quot;;&#xD;&#xA;&#x9;&#x9;&#x9;for(State nextState : nextStateSet) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for(Transition trans : nextState.getIncomingTransitions()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(trans.getLabel().equals(letterAsString)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;newStateSet.add(trans.getStartState());&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;newStateString += trans.getStartState().getId() + &quot;;&quot;;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;startState = getStateForStateID(startStateString, registry);&#xD;&#xA;&#x9;&#x9;&#x9;if(isFinal) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;startState.setFinalState(isFinal);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if (!newStateSet.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;boolean newState = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;for (State registryState : registry) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(compareStateId(registryState.getId(), newStateString)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;newState = false;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(newState == true) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;toDo.add(newStateSet);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;State newStateForStateSet = new State();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newStateForStateSet.setId(newStateString);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;registry.add(newStateForStateSet);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Transition transition = new Transition(startState, newStateForStateSet, letterAsString);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;startState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newStateForStateSet.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;State endState = getStateForStateID(newStateString, registry);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Transition transition = new Transition(startState, endState, letterAsString);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;startState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;endState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#x9;for (State state : registry) {&#xD;&#xA;&#x9;&#x9;if (!reversedAutomat.getStates().contains(state)) {&#xD;&#xA;&#x9;&#x9;&#x9;reversedAutomat.addState(state);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;if (!reversedAutomat.getFinalStates().contains(state) &amp;&amp; state.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;reversedAutomat.addFinalState(state);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;for (Transition transition : state.getOutgoingTransitions()) {&#xD;&#xA;&#x9;&#x9;&#x9;if(!reversedAutomat.getTransitions().contains(transition)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;reversedAutomat.addTransition(transition);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;automaton = reversedAutomat;&#xD;&#xA;}"/>
    <methods name="compareStateId(first,second)" pseudoCode="private boolean compareStateId(String firstString, String secondString) {&#xD;&#xA;&#x9;if(firstString.length() == secondString.length()) {&#xD;&#xA;&#x9;&#x9;String[] firstArray = firstString.split(&quot;;&quot;);&#xD;&#xA;&#x9;&#x9;String[] secondArray = secondString.split(&quot;;&quot;);&#xD;&#xA;&#x9;&#x9;for(int i = 0; i &lt; firstArray.length; i++){&#xD;&#xA;&#x9;&#x9;&#x9;String letterOfFirstString = firstArray[i];&#xD;&#xA;&#x9;&#x9;&#x9;boolean containsLetter = false;&#xD;&#xA;&#x9;&#x9;&#x9;for(int j = 0; j &lt; secondArray.length; j++) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;String letterOfSecondString = secondArray[j];&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(letterOfFirstString.equals(letterOfSecondString)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;containsLetter = true;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;if(containsLetter == false) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;return true;&#xD;&#xA;&#x9;} else {&#xD;&#xA;&#x9;&#x9;return false;&#xD;&#xA;&#x9;}&#xD;&#xA;}">
      <dataTypes name="String"/>
      <dataTypes name="String"/>
    </methods>
    <methods name="getStateForStateId(id,registry)" pseudoCode="private State getStateForStateID(String IdString, List&lt;State> registry) {&#xD;&#xA;&#x9;for(State state : registry) {&#xD;&#xA;&#x9;&#x9;if (compareStateId(IdString, state.getId())) {&#xD;&#xA;&#x9;&#x9;&#x9;return state;&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;return null;&#xD;&#xA;}">
      <dataTypes name="String"/>
      <dataTypes name="List&lt;State>"/>
    </methods>
  </Algorithms>
  <Algorithms name="Algorithm Sorted" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.List;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.Transition;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <dataStructures name="lexGreatestWord">
      <dataType name="String"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;String u = Util.longestCommonPrefix(lexGreatestWord, word);&#xD;&#xA;&#x9;String v = Util.leftDerivate(u, lexGreatestWord);&#xD;&#xA;&#x9;while(!v.isEmpty()) {&#xD;&#xA;&#x9;&#x9;u += Util.head(v);&#xD;&#xA;&#x9;&#x9;v = Util.tail(v);&#xD;&#xA;&#x9;&#x9;visitMin(u, v, word);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;lexGreatestWord = word;&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;visitMin(&quot;&quot;, lexGreatestWord, &quot;&quot;);&#xD;&#xA;}"/>
    <methods name="visitMin(left,right,word)" pseudoCode="private void visitMin(String left, String right, String word) {&#xD;&#xA;&#x9;&#x9;String completeWord = left + right;&#xD;&#xA;&#x9;&#x9;List&lt;State> states = Util.pathOfState(automaton.getStartState(), left);&#xD;&#xA;&#x9;&#x9;State state = states.get(states.size() - 1);&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;if(!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;left += Util.head(right);&#xD;&#xA;&#x9;&#x9;&#x9;visitMin(left, Util.tail(right), word);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;List&lt;State> checkStates = new ArrayList&lt;State>();&#xD;&#xA;&#x9;&#x9;if(!state.getOutgoingTransitions().isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;State endState = state.getOutgoingTransitions().get(0).getEndState();&#xD;&#xA;&#x9;&#x9;&#x9;for(Transition transition : endState.getIncomingTransitions()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;State startState = transition.getStartState();&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(startState.isFinalState() == state.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;checkStates.add(startState);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;} else if (state.isFinalState()) {&#xD;&#xA;&#x9;&#x9;&#x9;for (State tmpState : automaton.getFinalStates()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(tmpState.getOutgoingTransitions().isEmpty()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;checkStates.add(tmpState);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;State> pathOfStartState = Util.pathOfState(automaton.getStartState(), word);&#xD;&#xA;&#x9;&#x9;&#x9;checkStates.removeAll(pathOfStartState);&#xD;&#xA;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;State> pathOfStartState = Util.pathOfState(automaton.getStartState(), completeWord);&#xD;&#xA;&#x9;&#x9;&#x9;List&lt;State> pathOfStartState2 = Util.pathOfState(automaton.getStartState(), word);&#xD;&#xA;&#x9;&#x9;&#x9;for (State tmpState : automaton.getStates()) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;checkStates.add(tmpState);&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;checkStates.removeAll(pathOfStartState);&#xD;&#xA;&#x9;&#x9;&#x9;checkStates.removeAll(pathOfStartState2);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;&#x9;for(State q : checkStates) {&#xD;&#xA;&#x9;&#x9;&#x9;if(automaton.getStates().contains(state)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if (!q.equals(state)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(State.isEquivalenceFast(state, q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, state, q);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;} else {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}">
      <dataTypes name="String"/>
      <dataTypes name="String"/>
      <dataTypes name="String"/>
    </methods>
  </Algorithms>
  <Algorithms name="Algorithm Depth_Layered" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import java.util.ArrayList;&#xD;&#xA;import java.util.List;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <dataStructures name="minLength">
      <dataType/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;if(word.length() != minLength) {&#xD;&#xA;&#x9;&#x9;depthsMin(word.length(), minLength);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;minLength =  word.length();&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;depthsMin(0, minLength);&#xD;&#xA;}"/>
    <methods name="depthMin(i,j)" pseudoCode="private void depthsMin(int i, int j) {&#xD;&#xA;&#x9;List&lt;State> depthLevelIJ = new ArrayList&lt;State>();&#xD;&#xA;&#x9;List&lt;State> depthLevelBiggerJ = new ArrayList&lt;State>();&#xD;&#xA;&#x9;depthLevelIJ = Util.depthLevelBetweenIJ(automaton, i, j);&#xD;&#xA;&#x9;depthLevelBiggerJ = Util.depthLevelBiggerJ(automaton, j);&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;for (State p : depthLevelIJ) {&#xD;&#xA;&#x9;&#x9;if(automaton.getStates().contains(p)) {&#xD;&#xA;&#x9;&#x9;&#x9;for(State q : depthLevelIJ) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(automaton.getStates().contains(q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!q.equals(p)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(State.isEquivalence(p, q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, q, p);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;for (State p : depthLevelBiggerJ) {&#xD;&#xA;&#x9;&#x9;if(automaton.getStates().contains(p)) {&#xD;&#xA;&#x9;&#x9;&#x9;for(State q : depthLevelIJ) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(automaton.getStates().contains(q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!q.equals(p)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(State.isEquivalence(p, q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, q, p);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}">
      <dataTypes/>
      <dataTypes/>
    </methods>
  </Algorithms>
  <Algorithms name="Algorithm Semi_Incremental" parentAlgorithms="//@Algorithms.1" preCondition="" postCondition="" invariant="" imports="import java.util.HashSet;&#xD;&#xA;import java.util.List;&#xD;&#xA;import java.util.Set;&#xD;&#xA;&#xD;&#xA;import de.tu_bs.isf.madfa.algorithms.skeleton.AlgorithmSkeleton;&#xD;&#xA;import de.tu_bs.isf.madfa.automaton.State;&#xD;&#xA;import de.tu_bs.isf.madfa.util.Util;">
    <dataStructures name="automaton">
      <dataType name="Automaton"/>
    </dataStructures>
    <methods name="createMadfa(words)" pseudoCode="public Automaton createMadfa(List&lt;String> words) {&#xD;&#xA;&#x9;this.automaton = new Automaton();&#xD;&#xA;&#x9;State startState = new State();&#xD;&#xA;&#x9;this.automaton.addState(startState);&#xD;&#xA;&#x9;this.automaton.setStartState(startState);&#xD;&#xA;&#x9;List&lt;String> done = new ArrayList&lt;>();&#xD;&#xA;&#x9;List&lt;String> todo = new ArrayList&lt;>();&#xD;&#xA;&#x9;for(String tmpWord : words) {&#xD;&#xA;&#x9;&#x9;todo.add(tmpWord);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;for (Iterator&lt;String> it = todo.iterator(); it.hasNext();) {&#xD;&#xA;&#x9;&#x9;String nextWord = it.next();&#xD;&#xA;&#x9;&#x9;addWord(nextWord);&#xD;&#xA;&#x9;&#x9;done.add(nextWord);&#xD;&#xA;&#x9;&#x9;it.remove();&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;cleanup();&#xD;&#xA;&#x9;return this.automaton;&#xD;&#xA;}" preCondition="" postCondition=""/>
    <methods name="addWord(word)" pseudoCode="protected void addWord(String word) {&#xD;&#xA;&#x9;Set&lt;State> finals = new HashSet&lt;State>();&#xD;&#xA;&#x9;finals.addAll(automaton.getFinalStates());&#xD;&#xA;&#x9;State currentState = this.automaton.getStartState();&#xD;&#xA;&#x9;String left = &quot;&quot;;&#xD;&#xA;&#x9;String right = word;&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty() &amp;&amp; Util.stateExist(currentState, Util.head(right))) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;currentState = Util.getNextState(currentState, nextChar);&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;while (!right.isEmpty()) {&#xD;&#xA;&#x9;&#x9;String nextChar = Util.head(right);&#xD;&#xA;&#x9;&#x9;State newState = new State();&#xD;&#xA;&#x9;&#x9;Transition transition = new Transition(currentState, newState, nextChar);&#xD;&#xA;&#x9;&#x9;currentState.addOutgoingTransition(transition);&#xD;&#xA;&#x9;&#x9;newState.addIncomingTransition(transition);&#xD;&#xA;&#x9;&#x9;automaton.addState(newState);&#xD;&#xA;&#x9;&#x9;automaton.addTransition(transition);&#xD;&#xA;&#x9;&#x9;currentState = newState;&#xD;&#xA;&#x9;&#x9;left += nextChar;&#xD;&#xA;&#x9;&#x9;right = Util.tail(right);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#x9;&#xD;&#xA;&#x9;currentState.setFinalState(true);&#xD;&#xA;&#x9;automaton.addFinalState(currentState);&#x9;&#xD;&#xA;&#xD;&#xA;&#x9;List&lt;State> states = Util.pathOfState(automaton.getStartState(), word);&#xD;&#xA;&#x9;State state = states.get(states.size() - 1);&#xD;&#xA;&#x9;semiMin(state, finals);&#xD;&#xA;}">
      <dataTypes name="String"/>
    </methods>
    <methods name="cleanup()" pseudoCode="protected void cleanup() {&#xD;&#xA;&#x9;Set&lt;State> finals = new HashSet&lt;State>();&#xD;&#xA;&#x9;finals.addAll(automaton.getFinalStates());&#xD;&#xA;&#x9;finals.remove(automaton.getStartState());&#xD;&#xA;&#x9;semiMin(automaton.getStartState(), finals);&#xD;&#xA;}"/>
    <methods name="semiMin(p,listOfStatesU)" pseudoCode="private void semiMin(State p, Set&lt;State> listOfStatesU) {&#xD;&#xA;&#x9;Set&lt;State> listOfStatesV = new HashSet&lt;State>();&#xD;&#xA;&#x9;for(State q : Util.successorsOfState(p)) {&#xD;&#xA;&#x9;&#x9;if(!listOfStatesU.contains(q)) {&#xD;&#xA;&#x9;&#x9;&#x9;Set&lt;State> unionList = new HashSet&lt;State>();&#xD;&#xA;&#x9;&#x9;&#x9;unionList.addAll(listOfStatesU);&#xD;&#xA;&#x9;&#x9;&#x9;unionList.addAll(listOfStatesV);&#xD;&#xA;&#x9;&#x9;&#x9;semiMin(q, unionList);&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;listOfStatesV.add(q);&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;Set&lt;State> allSuccessors = new HashSet&lt;State>();&#xD;&#xA;&#x9;for(State tmp : listOfStatesU) {&#xD;&#xA;&#x9;&#x9;allSuccessors.add(tmp);&#xD;&#xA;&#x9;&#x9;List&lt;State> tmpList = Util.reachableStates(tmp);&#xD;&#xA;&#x9;&#x9;allSuccessors.addAll(tmpList);&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;for (State q : allSuccessors) {&#xD;&#xA;&#x9;&#x9;if(automaton.getStates().contains(q)) {&#xD;&#xA;&#x9;&#x9;&#x9;if (!q.equals(p)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;if(State.isEquivalenceFast(p, q)) {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Util.merge(automaton, p, q);&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;p = q;&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}">
      <dataTypes name="State"/>
      <dataTypes name="Set&lt;State>"/>
    </methods>
  </Algorithms>
</taxonomy:Taxonomy>
