/**
 * generated by Xtext 2.10.0
 */
package de.tu_bs.cs.isf.cbc.textual.tool.validation;

import com.google.common.base.Objects;
import de.tu_bs.cs.isf.cbc.cbcmodel.AbstractStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.CbcmodelPackage;
import de.tu_bs.cs.isf.cbc.cbcmodel.Condition;
import de.tu_bs.cs.isf.cbc.cbcmodel.MethodStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.ReturnStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SelectionStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SkipStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.SmallRepetitionStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.StrengthWeakStatement;
import de.tu_bs.cs.isf.cbc.cbcmodel.impl.AbstractStatementImpl;
import de.tu_bs.cs.isf.cbc.cbcmodel.impl.ReturnStatementImpl;
import de.tu_bs.cs.isf.cbc.util.CompareMethodBodies;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DslValidator extends AbstractDslValidator {
  public static final String INVALID_NAME = "invalidName";

  public static final String NOT_PROVED = "notProved";

  @Check
  public void checkSyntaxOfStatement(final AbstractStatement statement) {
    boolean _equals = statement.getClass().equals(AbstractStatementImpl.class);
    if (_equals) {
      if (((!Objects.equal(statement.getName(), null)) && (!statement.getName().isEmpty()))) {
        boolean _readAndTestMethodBodyWithJaMoPP2 = CompareMethodBodies.readAndTestMethodBodyWithJaMoPP2(statement.getName());
        boolean _not = (!_readAndTestMethodBodyWithJaMoPP2);
        if (_not) {
          this.warning("Statement has not the correct syntax.", 
            CbcmodelPackage.Literals.ABSTRACT_STATEMENT__NAME, 
            DslValidator.INVALID_NAME);
        }
      }
    }
  }

  @Check
  public void checkSyntaxOfRetunrStatement(final ReturnStatement statement) {
    boolean _equals = statement.getClass().equals(ReturnStatementImpl.class);
    if (_equals) {
      if (((!Objects.equal(statement.getName(), null)) && (!statement.getName().isEmpty()))) {
        boolean _readAndTestMethodBodyWithJaMoPP2 = CompareMethodBodies.readAndTestMethodBodyWithJaMoPP2(statement.getName());
        boolean _not = (!_readAndTestMethodBodyWithJaMoPP2);
        if (_not) {
          this.warning("Statement has not the correct syntax.", 
            CbcmodelPackage.Literals.ABSTRACT_STATEMENT__NAME, 
            DslValidator.INVALID_NAME);
        }
      }
    }
  }

  @Check
  public void checkSyntaxOfCondition(final Condition condition) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method readAndTestAssertWithJaMoPP(String) is undefined for the type Class<CompareMethodBodies>"
      + "\n! cannot be resolved");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfStatement(final AbstractStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfReturnStatement(final ReturnStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfStrengthWeakStatement(final StrengthWeakStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfMethodStatement(final MethodStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfSkipStatement(final SkipStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfRepetitionStatement(final SmallRepetitionStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }

  @Check(CheckType.EXPENSIVE)
  public void checkProveOfSelectionStatement(final SelectionStatement statement) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkFileIsProven(URI, int) is undefined for the type Class<ProveWithKey>");
  }
}
